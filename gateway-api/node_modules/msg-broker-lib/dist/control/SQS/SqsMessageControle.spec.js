"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SqsMessageControl_1 = require("./SqsMessageControl");
const client_sqs_1 = require("@aws-sdk/client-sqs");
describe("SqsMessageControl", () => {
    let sqsClientMock;
    let sqsControl;
    const queueUrl = "https://example.com/queue";
    const receiptHandle = "abc123";
    beforeEach(() => {
        sqsClientMock = {
            send: jest.fn(), // mock explícito do método send
        };
        sqsControl = new SqsMessageControl_1.SqsMessageControl(sqsClientMock, queueUrl, receiptHandle);
        jest.spyOn(console, "warn").mockImplementation(() => { });
    });
    afterEach(() => {
        jest.restoreAllMocks();
    });
    it("should call sqsClient.send with DeleteMessageCommand on ack", async () => {
        sqsClientMock.send.mockResolvedValue({}); // sem erro de tipagem
        await sqsControl.ack();
        expect(sqsClientMock.send).toHaveBeenCalledTimes(1);
        const command = sqsClientMock.send.mock.calls[0][0];
        expect(command).toBeInstanceOf(client_sqs_1.DeleteMessageCommand);
        expect(command.input).toEqual({
            QueueUrl: queueUrl,
            ReceiptHandle: receiptHandle,
        });
    });
    it("should call console.warn with error message on nack with error", async () => {
        const error = new Error("fail");
        await sqsControl.nack(error);
        expect(console.warn).toHaveBeenCalledWith("SQS nack: fail");
    });
    it("should call console.warn with 'unknown error' on nack without error", async () => {
        await sqsControl.nack();
        expect(console.warn).toHaveBeenCalledWith("SQS nack: unknown error");
    });
});
//# sourceMappingURL=SqsMessageControle.spec.js.map