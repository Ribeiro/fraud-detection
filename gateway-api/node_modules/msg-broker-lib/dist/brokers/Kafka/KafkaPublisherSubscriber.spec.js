"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const KafkaPublisherSubscriber_1 = require("./KafkaPublisherSubscriber");
const kafkajs_1 = require("kafkajs");
const KafkaMessageControl_1 = require("../../control/Kafka/KafkaMessageControl");
const buffer_1 = require("buffer");
jest.mock("kafkajs");
jest.mock("../../control/Kafka/KafkaMessageControl");
describe("KafkaPublisherSubscriber", () => {
    let kafkaMock;
    let producerMock;
    let consumerMock;
    let instance;
    beforeEach(() => {
        jest.clearAllMocks();
        producerMock = {
            connect: jest.fn().mockResolvedValue(undefined),
            send: jest.fn().mockResolvedValue(undefined),
            disconnect: jest.fn().mockResolvedValue(undefined),
        };
        consumerMock = {
            connect: jest.fn().mockResolvedValue(undefined),
            subscribe: jest.fn().mockResolvedValue(undefined),
            run: jest.fn().mockImplementation(async ({ eachMessage }) => {
                const message = {
                    key: buffer_1.Buffer.from("key1"),
                    value: buffer_1.Buffer.from(JSON.stringify({ foo: "bar" })),
                    headers: { header1: buffer_1.Buffer.from("value1") },
                    offset: "5",
                    timestamp: Date.now().toString(),
                    attributes: 0,
                };
                const payload = {
                    topic: "test-topic",
                    partition: 0,
                    message,
                    heartbeat: async () => { },
                    pause: () => {
                        return () => {
                            // Optionally do something here or leave empty
                        };
                    },
                };
                await eachMessage(payload);
            }),
            disconnect: jest.fn().mockResolvedValue(undefined),
        };
        kafkaMock = {
            producer: jest.fn().mockReturnValue(producerMock),
            consumer: jest.fn().mockReturnValue(consumerMock),
        };
        kafkajs_1.Kafka.mockImplementation(() => kafkaMock);
        instance = new KafkaPublisherSubscriber_1.KafkaPublisherSubscriber(["broker1:9092"]);
    });
    describe("publish", () => {
        it("should connect, send message and disconnect producer", async () => {
            const options = {
                destination: "my-topic",
                key: "key123",
                headers: { some: "header" },
            };
            const message = { foo: "bar" };
            await instance.publish(options, message);
            expect(producerMock.connect).toHaveBeenCalled();
            expect(producerMock.send).toHaveBeenCalledWith({
                topic: "my-topic",
                messages: [
                    {
                        key: "key123",
                        value: JSON.stringify(message),
                        headers: { some: "header" },
                    },
                ],
            });
            expect(producerMock.disconnect).toHaveBeenCalled();
        });
    });
    describe("subscribe", () => {
        it("should connect consumer, subscribe to topic and run consumer with eachMessage", async () => {
            const options = { destination: "test-topic", consumerGroup: "my-group" };
            const callback = jest.fn().mockResolvedValue(undefined);
            KafkaMessageControl_1.KafkaMessageControl.mockImplementation(() => ({
                ack: jest.fn(),
                nack: jest.fn(),
                retry: undefined,
            }));
            await instance.subscribe(options, callback);
            expect(kafkaMock.consumer).toHaveBeenCalledWith({ groupId: "my-group" });
            expect(consumerMock.connect).toHaveBeenCalled();
            expect(consumerMock.subscribe).toHaveBeenCalledWith({
                topic: "test-topic",
                fromBeginning: false,
            });
            expect(consumerMock.run).toHaveBeenCalled();
            expect(callback).toHaveBeenCalledWith({
                id: "key1",
                payload: { foo: "bar" },
                headers: { header1: "value1" },
            }, expect.any(Object));
            expect(KafkaMessageControl_1.KafkaMessageControl).toHaveBeenCalledWith(consumerMock, "test-topic", 0, "5");
        });
        it("should log error if callback throws", async () => {
            const options = { destination: "test-topic" };
            const error = new Error("fail");
            const callback = jest.fn().mockRejectedValue(error);
            jest.spyOn(console, "error").mockImplementation(() => { });
            await instance.subscribe(options, callback);
            expect(console.error).toHaveBeenCalledWith("Kafka message processing error:", error);
            jest.restoreAllMocks();
        });
    });
});
//# sourceMappingURL=KafkaPublisherSubscriber.spec.js.map