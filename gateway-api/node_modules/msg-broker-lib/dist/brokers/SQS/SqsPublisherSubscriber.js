"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqsPublisherSubscriber = void 0;
const client_sqs_1 = require("@aws-sdk/client-sqs");
const SqsMessageControl_1 = require("../../control/SQS/SqsMessageControl");
class SqsPublisherSubscriber {
    sqsClient;
    constructor(region) {
        this.sqsClient = new client_sqs_1.SQSClient({ region });
    }
    async publish(options, message) {
        const command = new client_sqs_1.SendMessageCommand({
            QueueUrl: options.destination,
            MessageBody: JSON.stringify(message),
            MessageAttributes: options.headers
                ? Object.entries(options.headers).reduce((acc, [key, value]) => {
                    acc[key] = {
                        DataType: "String",
                        StringValue: value,
                    };
                    return acc;
                }, {})
                : undefined,
        });
        await this.sqsClient.send(command);
    }
    async subscribe(options, callback) {
        const queueUrl = options.destination;
        const pollInterval = options.pollInterval || 5000;
        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
        const parseMessage = (rawMessage) => ({
            id: rawMessage.MessageId ?? "",
            payload: rawMessage.Body ? JSON.parse(rawMessage.Body) : null,
            headers: rawMessage.MessageAttributes
                ? Object.fromEntries(Object.entries(rawMessage.MessageAttributes).map(([k, v]) => [
                    k,
                    v.StringValue ?? "",
                ]))
                : {},
        });
        const processMessages = async (messages) => {
            for (const rawMessage of messages) {
                const parsedMessage = parseMessage(rawMessage);
                const control = new SqsMessageControl_1.SqsMessageControl(this.sqsClient, queueUrl, rawMessage.ReceiptHandle || "");
                try {
                    await callback(parsedMessage, control);
                }
                catch (err) {
                    console.error("SQS message processing error:", err);
                }
            }
        };
        const poll = async () => {
            while (true) {
                const result = await this.sqsClient.send(new client_sqs_1.ReceiveMessageCommand({
                    QueueUrl: queueUrl,
                    MaxNumberOfMessages: 10,
                    WaitTimeSeconds: 20,
                    MessageAttributeNames: ["All"],
                }));
                if (result.Messages) {
                    await processMessages(result.Messages);
                }
                await sleep(pollInterval);
            }
        };
        poll().catch((err) => {
            console.error("Polling failed:", err);
        });
    }
}
exports.SqsPublisherSubscriber = SqsPublisherSubscriber;
//# sourceMappingURL=SqsPublisherSubscriber.js.map